a:89:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"shell exec 　 解析";i:1;i:3;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:"　exec和source都属于bash内部命令（builtins commands），在bash下输入man exec或man source可以查看所有的内部命令信息。";}i:2;i:31;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:177;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:177;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:240:"bash shell的命令分为两类：外部命令和内部命令。外部命令是通过系统调用或独立的程序实现的，如sed、awk等等。内部命令是由特殊的文件格式（.def）所实现，如cd、history、exec等等。";}i:2;i:179;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:419;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:419;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"　　在说明exe和source的区别之前，先说明一下fork的概念。";}i:2;i:421;}i:11;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:497;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:497;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:282:"　　fork是linux的系统调用，用来创建子进程（child process）。子进程是父进程(parent process)的一个副本，从父进程那里获得一定的资源分配以及继承父进程的环境。子进程与父进程唯一不同的地方在于pid（process id）。";}i:2;i:499;}i:14;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:781;}i:15;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:781;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:230:" 环境变量（传给子进程的变量，遗传性是本地变量和环境变量的根本区别）只能单向从父进程传给子进程。不管子进程的环境变量如何变化，都不会影响父进程的环境变量。 ";}i:2;i:783;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1013;}i:18;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1013;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"shell script:";}i:2;i:1015;}i:20;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1028;}i:21;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1028;}i:22;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:167:"有两种方法执行shell scripts，一种是新产生一个shell，然后执行相应的shell scripts；一种是在当前shell下执行，不再启用其他shell。";}i:2;i:1030;}i:23;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1197;}i:24;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1197;}i:25;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:94:"新产生一个shell然后再执行scripts的方法是在scripts文件开头加入以下语句";}i:2;i:1199;}i:26;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1293;}i:27;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1293;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"#!/bin/sh";}i:2;i:1295;}i:29;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1304;}i:30;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1304;}i:31;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:135:"一般的script文件(.sh)即是这种用法。这种方法先启用新的sub-shell（新的子进程）,然后在其下执行命令。";}i:2;i:1306;}i:32;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1441;}i:33;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1441;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:"另外一种方法就是上面说过的source命令，不再产生新的shell，而在当前shell下执行一切命令。";}i:2;i:1443;}i:35;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1564;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1564;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"source:";}i:2;i:1566;}i:38;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1573;}i:39;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1573;}i:40;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"source命令即点(.)命令。";}i:2;i:1575;}i:41;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1605;}i:42;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1605;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:300:"在bash下输入man source，找到source命令解释处，可以看到解释”Read and execute commands from filename in the current shell environment and …”。从中可以知道，source命令是在当前进程中执行参数文件中的各个命令，而不是另起子进程(或sub-shell)。";}i:2;i:1607;}i:44;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1907;}i:45;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1907;}i:46;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" exec:";}i:2;i:1909;}i:47;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1915;}i:48;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1915;}i:49;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:212:"在bash下输入man exec，找到exec命令解释处，可以看到有”No new process is created.”这样的解释，这就是说exec命令不产生新的子进程。那么exec与source的区别是什么呢？";}i:2;i:1917;}i:50;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2129;}i:51;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2129;}i:52;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:101:"exec命令在执行时会把当前的shell process关闭，然后换到后面的命令继续执行。";}i:2;i:2131;}i:53;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2232;}i:54;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2232;}i:55;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:290:"1. 系统调用exec是以新的进程去代替原来的进程，但进程的PID保持不变。因此，可以这样认为，exec系统调用并没有创建新的进程，只是替换了原来进程上下文的内容。原进程的代码段，数据段，堆栈段被新的进程所代替。";}i:2;i:2238;}i:56;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2528;}i:57;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2528;}i:58;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:52:"一个进程主要包括以下几个方面的内容:";}i:2;i:2530;}i:59;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2582;}i:60;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2582;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"(1)一个可以执行的程序";}i:2;i:2584;}i:62;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2614;}i:63;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2614;}i:64;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"(2) 与进程相关联的全部数据(包括变量，内存，缓冲区)";}i:2;i:2616;}i:65;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2688;}i:66;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2688;}i:67;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:"(3)程序上下文(程序计数器PC,保存程序执行的位置) ";}i:2;i:2690;}i:68;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2756;}i:69;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2756;}i:70;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:"2. exec是一个函数簇，由6个函数组成，分别是以excl和execv打头的。";}i:2;i:2758;}i:71;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2844;}i:72;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2844;}i:73;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:889:"执行exec系统调用，一般都是这样，用fork()函数新建立一个进程，然后让进程去执行exec调用。我们知道，在fork()建立新进程之后，父进各与子进程共享代码段，但数据空间是分开的，但父进程会把自己数据空间的内容copy到子进程中去，还有上下文也会copy到子进程中去。而为了提高效率，采用一种写时copy的策略，即创建子进程的时候，并不copy父进程的地址空间，父子进程拥有共同的地址空间，只有当子进程需要写入数据时(如向缓冲区写入数据),这时候会复制地址空间，复制缓冲区到子进程中去。从而父子进程拥有独立的地址空间。而对于fork()之后执行exec后，这种策略能够很好的提高效率，如果一开始就copy,那么exec之后，子进程的数据会被放弃，被新的进程所代替。";}i:2;i:2846;}i:74;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3735;}i:75;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3735;}i:76;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" 3. exec与system的区别";}i:2;i:3737;}i:77;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3763;}i:78;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3763;}i:79;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:116:"(1) exec是直接用新的进程去代替原来的程序运行，运行完毕之后不回到原先的程序中去。";}i:2;i:3765;}i:80;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3881;}i:81;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3881;}i:82;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:151:"(2) system是调用shell执行你的命令，system=fork+exec+waitpid,执行完毕之后，回到原先的程序中去。继续执行下面的部分。";}i:2;i:3883;}i:83;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4034;}i:84;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4034;}i:85;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:141:"总之，如果你用exec调用，首先应该fork一个新的进程，然后exec. 而system不需要你fork新进程，已经封装好了。";}i:2;i:4036;}i:86;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4177;}i:87;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4178;}i:88;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:4178;}}