a:81:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:56:"shell如何获取后天运行的子进程的退出状态";i:1;i:3;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:154:"一个命令的执行成功与否（即退出值）可以通过echo $?来获得，然而把命令放到后台执行后，如何获取命令的退出值？";}i:2;i:68;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:222;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:222;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:41:"for example：
ls -l my & #my不存在的";}i:2;i:224;}i:8;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:265;}i:9;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:265;}i:10;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:44:"正常的执行ls -l my后
再echo $?得到2";}i:2;i:267;}i:11;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:311;}i:12;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:311;}i:13;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"但ls -l my &后echo $?得到0";}i:2;i:313;}i:14;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:343;}i:15;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:343;}i:16;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:"怎么去获得命令的真正的退出状态";}i:2;i:345;}i:17;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:390;}i:18;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:390;}i:19;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:315:"放到后台去执行，前台已经不管其执行情况了，返回的仅仅是放入后台这个操作成功与否而非命令本身，那肯定都是成功的。
后台获取ls -l 命令的执行情况，可以考虑将错误输出流（2）导入标准输出（1）获取命令打印结果加以判断。如：";}i:2;i:393;}i:20;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:714;}i:21;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:286:"

ret=`ls -l my 2>&1 &`
# 如果是用脚本执行的话，需要在这里判断进程是否存在，等待命令执行完；或者sleep足够长的时间
echo $ret | grep "No such file or directory" >/dev/null 2>&1
if [ $? -eq 0 ]; then
    echo "Failed"
else
    echo "Successful"
fi
";i:1;s:4:"bash";i:2;N;}i:2;i:714;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:714;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:244:"或者也可以考虑写文件的方式，若后台命令执行发生错误，写错误日志，判断存在错误日志且大小不为0，就能知道命令执行发生错误了。这样做的好处是，不涉及具体错误信息的判断。";}i:2;i:1016;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1266;}i:25;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:51:"
errlog=/tmp/err.log

size=0

ls -l my 2>$errlog &
";i:1;N;i:2;N;}i:2;i:1266;}i:26;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:260:"
# 如果是用脚本执行的话，需要在这里判断进程是否存在，等待命令执行完；或者sleep足够长的时间
[ -f $errlog ] && size=`wc -c $errlog | cut -d' ' -f1`
if [ $size -gt 0 ]; then
    echo "Failed"
else
    echo "Successful"
fi
";i:1;s:4:"bash";i:2;N;}i:2;i:1332;}i:27;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1332;}i:28;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"追问";}i:2;i:1606;}i:29;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1612;}i:30;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1612;}i:31;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:250:"恩，这样是可以的，但我想知道后台进程的确切的exit code呢，如何捕获？比方说，ls -l my 用echo $?得到的值为2，但ls -l my &后echo $?得到的值是0，但其实是2，我怎么才能获取真正的退出值2呢？";}i:2;i:1614;}i:32;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1864;}i:33;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1864;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"回答";}i:2;i:1866;}i:35;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1872;}i:36;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1872;}i:37;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:47:"一块儿放到后台去：
ls -l my; echo $? &";}i:2;i:1874;}i:38;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1921;}i:39;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1921;}i:40;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"追问";}i:2;i:1923;}i:41;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1929;}i:42;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1929;}i:43;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:"那如果是远程执行命令呢？比方说 ssh host ";}i:2;i:1931;}i:44;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:1986;}i:45;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"ls -l my";}i:2;i:1987;}i:46;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:1995;}i:47;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:" &,怎么获取远程执行的这条命令的退出状态值呢？";}i:2;i:1996;}i:48;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2062;}i:49;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2062;}i:50;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"回答";}i:2;i:2064;}i:51;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2070;}i:52;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2070;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:271:"后台执行命令，结果就在后台；远程执行命令，结果就在远程设备端。就看你怎样取到前台和本地来。
自己想想喏~~
我还是建议用我上面的存文件方法，便于分析失败原因，只有一个状态码往往是不够的。";}i:2;i:2072;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2343;}i:55;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2343;}i:56;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"追问";}i:2;i:2345;}i:57;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2351;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2351;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:242:"状态值是子进程返回给调用它的父进程的，远程执行，父进程在本地，子进程在远程设备上，那这个状态码应该会被ssh返回给本地的吧，那我们还是能够获取的呀。比方说，ssh localhost ";}i:2;i:2353;}i:60;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:2595;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"ls -l my";}i:2;i:2596;}i:62;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:2604;}i:63;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:50:"后echo $?得到2，说明状态码返回过来了";}i:2;i:2605;}i:64;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2655;}i:65;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2655;}i:66;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"回答";}i:2;i:2657;}i:67;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2663;}i:68;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2663;}i:69;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:"既然这样，那不还是一样的嘛。一块儿放到后台去：
ssh host ";}i:2;i:2665;}i:70;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:2744;}i:71;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"ls -l my";}i:2;i:2745;}i:72;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:2753;}i:73;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"; echo $? &";}i:2;i:2754;}i:74;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2765;}i:75;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2765;}i:76;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"提问者评价";}i:2;i:2767;}i:77;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2783;}i:78;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:41:"  谢谢你的耐心解答，好详细呀";}i:2;i:2783;}i:79;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:2829;}i:80;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:2829;}}