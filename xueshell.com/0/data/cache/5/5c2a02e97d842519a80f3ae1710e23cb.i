a:153:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:0;}i:2;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:"shell 与 export命令";}i:2;i:1;}i:3;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23;}i:4;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23;}i:5;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:110:"用户登录到Linux系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令";}i:2;i:25;}i:6;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:135;}i:7;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:135;}i:8;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:"或声明变量，也可以创建并运行shell脚本程序。运行shell脚本程序时，系统将创建一个子shell。";}i:2;i:137;}i:9;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:260;}i:10;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:260;}i:11;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"此时，系统中将有两个shell，一个是登录时系统启动的shell，另一个是系统为运行脚本程序创建";}i:2;i:262;}i:12;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:386;}i:13;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:386;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"的shell。当一个脚本程序运行完毕，脚本shell将终止，返回到执行该脚本之前的shell。";}i:2;i:388;}i:15;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:499;}i:16;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:499;}i:17;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:120:"从这种意义上来说，用户可以有许多 shell，每个shell都是由某个shell（称为父shell）派生的。";}i:2;i:504;}i:18;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:624;}i:19;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:624;}i:20;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:117:"在子shell中定义的变量只在该子shell内有效。如果在一个shell脚本程序中定义了一个变量，";}i:2;i:626;}i:21;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:743;}i:22;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:743;}i:23;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:131:"当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的shell不能引用它，";}i:2;i:745;}i:24;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:876;}i:25;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:876;}i:26;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:119:"要使某个变量的值可以在其他shell中被改变，可以使用export命令对已定义的变量进行输出。";}i:2;i:878;}i:27;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:997;}i:28;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:997;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:"export命令将使系统在创建每一个新的shell时，定义这个变量的一个拷贝。";}i:2;i:1002;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1097;}i:31;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1097;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:"这个过程称之为变量输出。";}i:2;i:1099;}i:33;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1135;}i:34;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1135;}i:35;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"［例］";}i:2;i:1137;}i:36;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1146;}i:37;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1146;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:68:"在本例中，变量myfile是在dispfile脚本程序中定义的。";}i:2;i:1148;}i:39;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1216;}i:40;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1216;}i:41;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:"然后用export命令将变量myfile输出至任何子shell，例如当执行printfile脚本程序时产生的子shell。";}i:2;i:1218;}i:42;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1339;}i:43;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1339;}i:44;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:"dispfile脚本程序清单：";}i:2;i:1341;}i:45;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1370;}i:46;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:263:"

myfile=”List”
export myfile
echo “Displaying $myfile”
pr –t –n $myfile
printfile

　
printfile脚本程序清单：

echo “Printing $myfile”
lpr $myfile&

 

运行结果：

$dispfile
Displaying List
1 screen
2 modem
3 paper
Printing List
$

 ";i:1;s:4:"bash";i:2;N;}i:2;i:1378;}i:47;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1378;}i:48;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:53:"export 功能说明：设置或显示环境变量。 ";}i:2;i:1656;}i:49;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1709;}i:50;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1709;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:"语　　法：export [-fnp][变量名称]=[变量设置值]";}i:2;i:1711;}i:52;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1771;}i:53;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1771;}i:54;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:205:"补充说明：在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅限于该次登陆操作。";}i:2;i:1773;}i:55;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1978;}i:56;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1978;}i:57;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"参　　数：   ";}i:2;i:1984;}i:58;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:2002;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:"
　-f 　代表[变量名称]中为函数名称。   ";}i:2;i:2004;}i:60;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:2058;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:"
　-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。   ";}i:2;i:2060;}i:62;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:2181;}i:63;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:61:"
　-p 　列出所有的shell赋予程序的环境变量。 ";}i:2;i:2183;}i:64;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:2244;}i:65;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2247;}i:66;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2247;}i:67;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:"从学习export命令理解到的Shell环境和变量生存期";}i:2;i:2257;}i:68;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2319;}i:69;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2319;}i:70;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:3:"　";}i:2;i:2321;}i:71;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:1;i:1;s:7:"#800000";}i:2;i:1;i:3;s:12:"<fc #800000>";}i:2;i:2324;}i:72;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:3;i:1;s:709:"　最近在学习BASH的export命令时碰到了一个难道（书上说export是将自定义变量变成

系统环境变量）：我在一个脚本文件中定义一个了变量，然后export变量，按照我自己的想法，

执行完这个脚本后，在提示符下一定可以用echo显示出它的值，可结果却不是这样，脚本执行完后

用set根本看不到有这个变量存在。为什么呢？我百思不得其解，最后将问题贴出来，一位前辈告诉

我说用source+脚本文件就可以了，我试了一下果然可以，但一个新的问题又出来了。我将脚本中

export命令删除后，用source一样可以。那这个export好像没有什么用呀。";}i:2;i:3;i:3;s:709:"　最近在学习BASH的export命令时碰到了一个难道（书上说export是将自定义变量变成

系统环境变量）：我在一个脚本文件中定义一个了变量，然后export变量，按照我自己的想法，

执行完这个脚本后，在提示符下一定可以用echo显示出它的值，可结果却不是这样，脚本执行完后

用set根本看不到有这个变量存在。为什么呢？我百思不得其解，最后将问题贴出来，一位前辈告诉

我说用source+脚本文件就可以了，我试了一下果然可以，但一个新的问题又出来了。我将脚本中

export命令删除后，用source一样可以。那这个export好像没有什么用呀。";}i:2;i:2336;}i:73;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:9:"fontcolor";i:1;a:2:{i:0;i:4;i:1;s:4:"#ff0";}i:2;i:4;i:3;s:5:"</fc>";}i:2;i:3045;}i:74;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3050;}i:75;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3050;}i:76;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:129:"　　在经过多次尝试后发现了一些东西，是我自己猜的，如果有什么不对的地方，请指正，谢谢。";}i:2;i:3052;}i:77;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3181;}i:78;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3181;}i:79;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:125:"　　执行一个脚本时，会先开启一个子shell环境（不知道执行其它程序是不是这样），然后将父";}i:2;i:3183;}i:80;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3308;}i:81;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3308;}i:82;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:"shell中的所有系统环境变量复制过来，这个脚本中的语句就在子shell中执行。（也就是说父shell";}i:2;i:3310;}i:83;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3433;}i:84;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3433;}i:85;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:239:"的环境变量在子shell中可以调用，但反过来就不行，如果在子shell中定义了环境变量，只对该shell
或者它的子shell有效，当该子shell结束时，也可以理解为脚本执行完时，变量消失。）";}i:2;i:3435;}i:86;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3674;}i:87;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3674;}i:88;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:"为了证明这一点，请看脚本内容：";}i:2;i:3676;}i:89;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3727;}i:90;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:176:"

　　test='value'
　　export test
　　这样的脚本执行完后，test实际上是不存在的。接着看下面的：
　　test='value'
　　export test
　　bash
";i:1;N;i:2;N;}i:2;i:3727;}i:91;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3727;}i:92;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:122:"　　这里在脚本最后一行再开一个子shell，该shell应该是脚本文件所在shell的子shell，这个脚本";}i:2;i:3914;}i:93;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4036;}i:94;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4036;}i:95;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:"执行完后，是可以看到test这个变量的，因为现在是处于它的子shell中，当用exit退出子shell后，";}i:2;i:4038;}i:96;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4161;}i:97;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4161;}i:98;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"test变量消失。";}i:2;i:4163;}i:99;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4182;}i:100;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4182;}i:101;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:113:"　　如果用source对脚本进行执行时，如果不加export，就不会在子shell中看到这个变量，";}i:2;i:4184;}i:102;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4297;}i:103;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4297;}i:104;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:76:"因为它还不是一个系统环境变量呀，如脚本内容是：
　　";}i:2;i:4299;}i:105;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4375;}i:106;a:3:{i:0;s:12:"preformatted";i:1;a:1:{i:0;s:14:"  test='value'";}i:2;i:4375;}i:107;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4375;}i:108;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:118:"　
　用source执行后，在shell下是能看到这个变量，但再执行bash开一个子shell时，test是不会";}i:2;i:4393;}i:109;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4511;}i:110;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4511;}i:111;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"被复制到子shell中的，因为执行脚本文件其实也是在一个子shell中运行，所以我再建另一个脚本";}i:2;i:4513;}i:112;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4637;}i:113;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4637;}i:114;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:124:"文件执行时，是不会输入任何东西的，内容如：echo $test。所以这点特别注意了，明明在提示符";}i:2;i:4639;}i:115;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4763;}i:116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4763;}i:117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:"下可以用echo $test输出变量值，为什么把它放进脚本文件就不行了呢？";}i:2;i:4765;}i:118;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4856;}i:119;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4856;}i:120;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:"　　所以得出的结论是：";}i:2;i:4858;}i:121;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:4891;}i:122;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4893;}i:123;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4893;}i:124;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:101:"1、执行脚本时是在一个子shell环境运行的，脚本执行完后该子shell自动退出；";}i:2;i:4895;}i:125;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:4996;}i:126;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4998;}i:127;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4998;}i:128;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:"2、一个shell中的系统环境变量会被复制到子shell中（用export定义的变量）；";}i:2;i:5000;}i:129;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:5098;}i:130;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5100;}i:131;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5100;}i:132;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:"3、一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失";}i:2;i:5102;}i:133;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:5213;}i:134;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:"
（并不能返回到父shell中）。";}i:2;i:5215;}i:135;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5254;}i:136;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5254;}i:137;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:83:"3、不用export定义的变量只对该shell有效，对子shell也是无效的。";}i:2;i:5256;}i:138;a:3:{i:0;s:9:"linebreak";i:1;a:0:{}i:2;i:5339;}i:139;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5341;}i:140;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5341;}i:141;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:159:"整理了一下贴子：为什么一个脚本直接执行和用source执行不一行呢？这也是我自己碰到的一个问题。manual原文是这样的：";}i:2;i:5346;}i:142;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5505;}i:143;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5505;}i:144;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:143:"Read and execute commands from filename in the current shell environment and
return the exit status of the last command executed from filename.";}i:2;i:5507;}i:145;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5650;}i:146;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5650;}i:147;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:119:"明白了为什么不一样了吧？直接执行一个脚本文件是在一个子shell中运行的，而source则是在";}i:2;i:5652;}i:148;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5771;}i:149;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5771;}i:150;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:"当前shell环境中运行的。根据前面的内容，你也已经明白其中的道理了吧。";}i:2;i:5773;}i:151;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5773;}i:152;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:5773;}}