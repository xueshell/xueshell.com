=====版本控制系统 =====

====版本控制====

版本控制(Revision control)是一种软件工程技巧，籍以在开发的过程中，确保由不同人所编辑的同一档案都得到更新。 
版本控制透过文档控制（documentation control）记录程序各个模组的改动，并为每次改动编上序号。 
这种方法是工程图维护（maintenance of engineering drawings）的标准做法， 它伴随着工程图从图的诞生一直到图的定型。 
一种简单的版本控制形式，例如，赋给图的初版一个版本等级“A”。 
当做了第一次改变后，版本等级改为“B”，以此类推。 不仅存在着保存着工程图或者软件源代码的文本文件版本控制管理，而实际上，你可以对任何类型的文件进行版本控制。 
版本控制系统用于维护文件的所有版本，随着时间的推移，系统逐渐产生这些版本。 


使用版本控制系统，人们可以返回到各个文件以前的修订版本，还可以比较任意两个版本以查看它们之间的变化。 通过这种方式，版本控制可以保留一个文件修订的可检索的准确历史日志，甚至将整个项目都回退到过去某个时间点的状态。 
更重要的是，版本控制系统有助于多个人（甚至位于完全不同的地理位置）通过 Internet 或 专用网将各自的更改合并到同一个源存储库，从而协同开发项目。 而由此额外增加的工作量却微乎其微。

====为什么要用版本控制 ====

如果没有版本控制工具的协助，在开发中我们经常会遇到下面的一些问题：
  * 代码管理混乱。 
如果是别人添加或删除一个文件，你很难发现。 没有办法对文件代码的修改追查跟踪。 
甚至出现文件丢失，或新版本代码被同伴无意覆盖等现象。 
  * 解决代码冲突困难。 
当大家同时修改一个公共文件时，解决代码冲突是一件很头疼的事。 
最原始的办法是手工打开冲突文件，逐行比较，再手工粘贴复制。 
更高级的做法是使用文件比较工具，但仍省不了繁杂的手工操作，一不小心，甚至会引入新的bug。
  * 在代码整合期间引入深层BUG。 
例如开发者A写了一个公共函数，B觉得正好可以复用；后来A又对这个公共函数进行了修改，添加了新的逻辑，而这个改动的却是B不想要的。 
或者是A发现这个公共函数不够用，又新做了一个函数，B却没有及时获得通知。 
这些，都为深层BUG留下隐患。
  * 无法对代码的拥有者进行权限控制。 
代码完全暴露在所有的开发者面前，任何人都可以随意进行增、删、改操作，无法指定明确的人对代码进行负责。 特别是产品的开发，这是极其危险的。
  * 项目不同版本发布困难。 
特别是对产品的开发，你会频繁的进行版本发布，这时如果没有一个有效的管理产品版本的工具，一切将变得非常艰难。 

上面只是列举了一些没有版本控制系统可能带来的问题，特别是对大型项目和异地协同开发有了一个合适的版本控制工具，它可以有效解决因为代码版本不同引起的各种问题，让我们的开发人员能更多的把精力花费在开发上面。 而不是每次都花费很多时间进行代码整合和解决版本不同带来的各种问题。 

====版本控制系统的发展历史====

===本地版本控制系统 ===

许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 
这么做唯一的好处就是简单，不过坏处却不少：有时候会混淆所在的工作目录，弄错了文件丢了数据就没了退路。 为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。 
其中最流行的一种叫做 rcs，现今许多计算机系统上都还看得到它的踪影。 
甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 
它的工作原理基本上就是保存并管理文件补丁。 
文件补丁是一种特定格式的文本文件，记录着对应文件修订前后的内容变化。所以，根据每次修订后的补丁，rcs 可以通过不断打补丁，计算出各个版本的文件内容。

===集中化的版本控制系统 ===

接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 
于是，集中化的版本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。 
这类系统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 
多年以来，这已成为版本控制系统的标准做法。 
这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。 
现在，每个人都可以一定程度上看到项目中的其他人正在做些什么。 
而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库轻松容易得多。 
事分两面，有好有坏。 
这么做最显而易见的缺点是中央服务器的单点故障。 若是服务器当机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 
如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。 
最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新信息的风险。 

===分布式版本控制系统 ===
于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世了。 
在这类系统中，诸如 Git，Mercurial，Bazaar 还有 Darcs 等，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。 
这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 
因为每一次的提取操作，实际上都是一次对代码仓库的完整备份。 
更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。 
籍此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。 
你可以根据需要设定不同的协作流程，比方说层次模型式的工作流，这在以前的集中式系统中是无法实现的。

====常见版本控制系统 1.Subversion ====

Subversion是一个版本控制系统，相对于的RCS、CVS，
采用了分支管理系统，它的设计目标就是取代CVS。互联网上免费的版本控制服务多基于Subversion。

Git 
Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git是Linux Torvalds为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。 3.Darcs 

Darcs是新一代轻量级分布式版本控制系统。完全使用Haskell编写而成。不同于以往的版本控制系统，Darcs没有中央服务器。任何一个本地repository都可以既是客户端也是服务器，节点之间可以任意同步。这样我们可以不依赖网络离线comit任何修改。 

Bazaar 
Bazaar是一个分布式的版本控制系统，它发布在GPL许可协议之下，并可用于Windows、GNU/Linux、UNIX以及Mac OS系统。Bazaar由Canonical公司赞助，目前已服务于Samba、Drupal等知名的开源项目。Bazaar当前已经包含许多有用的功能，这些功能使之具有如下鲜明的特点：容易使用、稳定可靠、使用灵活。Bazaar也包括智能合并、支持插件、可与第三方工具整合、文档支持等其他特性。 

Mercurial 
Mercurial是一种轻量级分布式版本控制系统，采用Python语言实现，易于学习和使用，扩展性强。相对于传统的版本控制，具有如下优点： 
更轻松的管理：传统的版本控制系统使用集中式的repository，一些和repository相关的管理就只能由管理员一个人进行。由于采用了分布式的模型，Mercurial中就没有这样的困扰，每个用户管理自己的repository，管理员只需协调同步这些repository。 
更健壮的系统：分布式系统比集中式的单服务器系统更健壮，单服务器系统一旦服务器出现问题整个系统就不能运行了，分布式系统通常不会因为一两个节点而受到影响。 更低的网络依赖性：由于同步可以放在任意时刻进行，Mercurial甚至可以离线进行管理，只需在有网络连接时同步
FOssil 
Fossil是一个简单、高可靠性的分布式软件配置管理系统。值得关注的功能：Bug跟踪和Wiki、Web接口、自动同步、支持HTTP接口、嵌入式CGI、稳健而且可靠

OpenCVS 
OPENCVS是自由的协作版本系统(CVS)实现，CVS是最流行的开放源代码版本控制软件。它可以用于客户端，以及服
务器端的版本库，提供了对存储在版本库中的数据的细粒度访问控制。它的目标是除了完全减少系统安全性的特性之外，尽可能的与其它的CVS实现兼容。OPENCVS项目是在最近GNU CVS弱点暴露之后，经过讨论之后启动的。尽管CVS被广泛使用，但是最近几年它的开发已经基本停止了。CVS的实现和设计，已经被发现许多安全问题。 8.Monotone 
monotone是一个分布式版本控制系统，提供了简单的、单文件事务版本存储和点对点同步协议，支持历史版本敏感的合并操作、轻量级分支处理以及集成代码评审和第三方测试工具。使用加密的版本命令方式和客户端RSA认证，很好的支持国际化，不依赖第三方工具，支持跨平台。 

CVS 
CVS(Concurrent Versions System)老牌的版本控制系统，它是基于客户端/服务器的行为使得其可容纳多用户，构成网络也很方便。这一特性使得CVS成为位于不同地点的人同时处理数据文件(特别是程序的源代码)时的首选。  


